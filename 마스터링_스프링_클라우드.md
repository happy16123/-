# Chap.1
## 마이크로서비스?
- IT 시스템 아키텍처 접근 방식 중 하나
- 비즈니스 요구사항을 구현한 하나의 애플리케이션을 느슨하게 연결된 여러 애플리케이션으로 쪼개는 것
- 서비스 기반 아키텍처(SOA) 개념의 다른 형태
- 가장 중요한 혜택 중 하나는 대규모의 복잡한 애플리케이션을 지속해서 배포하는 능력
- 확장성, 유연성, 독립적 배포성과 같은 장점이 있음

## 클라우드 네이티브
"클라우드 네이티브는 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다"
– MS

"클라우드 네이티브 애플리케이션은 탄력적으로 결합된 소규모의 독립 서비스 컬렉션이다."
– Pivotal

"클라우드 네이티브 애플리케이션은 처음부터 클라우드 규모의 크기 조정 및 성능에 최적화되도록 빌드 된다.
이 솔루션은 마이크로 서비스 아키텍처를 기반으로 하며, 관리되는 서비스를 사용하고,
지속적인 업데이트를 활용해 안정성을 확보하고 출시 시간을 단축한다."
– RedHat

## 마이크로서비스 아키텍처
- 시스템 내부에서 어떤 서비스와 통신하는지 알 필요가 없는 외부의 API 클라이언트에게는 시스템의 복잡도를 숨긴다
- 게이트웨이는 클라이언트의 모든 요청을 다양한 API 종단점으로 동적으로 전달
- 동적이라는 말은 서비스 디스커버리의 목록에 기반한다는 뜻
- API게이트웨이는 시스템으로의 진입점이기 때문에 중요한 데이터를 추적하거나 요청 메트릭스를 수집하고 통계를 내기 좋은 장소가 될 수 있다
- 부가정보를 삽입하기 위해 요청 및 응답 헤더를 조작할 수도 있다

## 서비스 디스커버리의 필요성
- 컴퓨터 네트워크상의 디바이스가 제공하는 디바이스와 서비스를 자동으로 감지하는 서비스
- 모든 서비스는 시작 후 다른 서비스가 접근할 수 있는 하나의 중앙 장소에 자신을 등록


## 서비스 간 통신
- 시스템의 신뢰성을 보장하려면 각 서비스가 하나의 인스턴스로만 운영되게 하면 안된다
- 같은 서비스의 여러 인스턴스는 들어오는 요청에 대해 부하 분산을 적용해야 한다
- 부하 분산기는 대개 API 게이트웨이에 내장돼 있다
- 특별한 이유가 없다면 유입되는 트래픽을 50/50으로 모든 실행 중인 인스턴스에 분배하는 라운드 로빈 규칙을 적용한다

## 장애와 서킷 브레이커
- 대부분 장애의 발생 원인은 네트워크 또는 데이터베이스의 문제와 같이 관리의 범위를 벗어난다
- 하나의 요청이 많은 후속 호출에서 처리되는 마이크로서비스 기반의 시스템에서는 심각할 수 있다
- 가장 좋은 방법은 응답을 기다릴 때 네트워크 타임아웃을 활용하는 것이다
- 장시간 응답을 기다려서 스레드를 점유하는 대신 에러 응답을 보내는 것이 낫다
- 네트워크 타임아웃 문제에 대한 흥미로운 해결책은 서킷 브레이커 패턴일 수 있다
- 서킷 브레이커는 성공 및 실패 요청의 횟수를 센다
- 에러 비율이 가정된 임계치를 넘으면 차단이 발생하고 이후 즉시 실패된다
---
# Chap.2
## Configuration File 사용자 정의
- .properties와 .yml 위치
    - 애플리케이션의 현재 디렉토리의 /config 하위 디렉토리
    - 애플리케이션의 현재 니렉토리
    - 클래스 경로/config 패키지
    - 클래스 경로 root

## Spring Boot Actuator
- 애플리케이션의 모니터링과 메트릭 수집이 중요하다
- Boot 2 버전 부터 CounterService 및 GaugeService는 MeterRegistry로 이동되었다
- 문서화와 메트릭, 상태 점검에 많은 부분이 마이크로서비스를 개발하고 유지보수하는 데 매우 중요하다
- 하지만, 스프링 부트는 이러한 것을 즉시 제공하므로 개발자가 거기에 너무 많은 시간을 할애하지 않아도 된다
---
 # Chap.3
## 12-팩터 앱
- 확장이 가능하고 쉽게 클라우드 플랫폼에 배포할수 있으며 지속 배포 프로세스에 따라 배포되는 SaaS 개발 방법론
[참고](https://medium.com/dtevangelist/12-factors-%EB%9E%80-b39c7ef1ed30)

## 넷플릭스(Netflix) OSS
- 모놀리식 애플리케이션 기반의 전통적인 개발 모델에서 클라우드-네이티브 마이크로서비스 기반 개발 방식으로 전환한 선구자

## 유레카를 사용한 서비스 디스커버리
- 이 패키지는 클라이언트와 서버로 구분
- 클라이언트는 항상 애플리케이션의 일부로 원격의 디스커버리 서버에 연결하는 일을 담당
- 서비스 이름과 네트워크 위치를 담은 등록 메시지를 보낸다
- 서버는 독립적은 스프링 부트 애플리케이션으로 설정되고 실행되는데, 각 서버의 상태를 다른 서버에 복제해 가용성이 높다

## 주울을 사용한 라우팅
- JVM 기반의 라우터이며 서버 측 부하 분산과 일부 필터링을 수행
- 전체 시스템의 진입점을 제공하는 API 게이트웨이로서 중요한 역할을 한다
- 각 서비스의 네트워크 위치 정보를 알아야 하므로 유레카 서버와 통신하기 위해 디스커버리 클라이언트를 클래스 경로로 포함한다

## 리본을 사용한 부하 분산
- 클라이언트 측 부하 분산기
- TCP, UDP, HTTP 프로토콜 지원
- 동기 방식의 REST 호출뿐 아니라 비동기 또는 리액티브 모델도 지원
- 라운드 로빈, 가용성 필터링, 응답 시간에 가중치를 두어 부하 분산을 하는 등의 규칙을 즉시 제공하고 사용자 정의 규칙을 쉽게 확장할 수 있다
- 이름 기반 부하 분산을 하는 네임드 클라이언트 개념에 기반

## 자바 HTTP 클라이언트 작성하기
- 페인(Feign) 넷플릭스 OSS 패키지 중 약간 인기가 떨어진다
- 선언적인 REST 클라이언트로, 웹 서비스 클라이언트를 쉽게 작성하도록 도와준다
- 애노테이션을 선언하기만 하면 애플리케이션이 실행될 때 실제 구현이 실행된다

## 히스트릭스를 사용해 대기 시간 및 장애 내성 다루기
- 서킷 브레이커 패턴을 구현한 히스트릭스 패키지
- 리본과 페인 클라이언트를 통합할 수 있다


## 디스커버리와 분산 컨피규레이션
- 서비스 디스커버리와 분산 컨피규레이션 관리는 마이크로서비스 아키텍처에서 중요한 부분이다
- 아파치 주키퍼
    - 컨피규레이션과 이름을 유지하는 중앙 서비스로의 분산 동기호, 그룹 서비스를 가능하게 한다
- 쿠버네티스
    - 구글에서 설계된 시스템으로서 배포, 확장, 애플리케이션 컨테이너의 관리를 자동화는 시스템
- 슬루스를 사용한 분산 추적
    - 스프링 클라우드의 필수 기능 중 하나의 분산추적이다.
    - 대부분의 경우는 HTTP 헤더에 기반한 메커니즘으로 추적을 구현

....


