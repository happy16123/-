# Chap.1
## 마이크로서비스?
- IT 시스템 아키텍처 접근 방식 중 하나
- 비즈니스 요구사항을 구현한 하나의 애플리케이션을 느슨하게 연결된 여러 애플리케이션으로 쪼개는 것
- 서비스 기반 아키텍처(SOA) 개념의 다른 형태
- 가장 중요한 혜택 중 하나는 대규모의 복잡한 애플리케이션을 지속해서 배포하는 능력
- 확장성, 유연성, 독립적 배포성과 같은 장점이 있음

## 클라우드 네이티브
"클라우드 네이티브는 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식이다"
– MS

"클라우드 네이티브 애플리케이션은 탄력적으로 결합된 소규모의 독립 서비스 컬렉션이다."
– Pivotal

"클라우드 네이티브 애플리케이션은 처음부터 클라우드 규모의 크기 조정 및 성능에 최적화되도록 빌드 된다.
이 솔루션은 마이크로 서비스 아키텍처를 기반으로 하며, 관리되는 서비스를 사용하고,
지속적인 업데이트를 활용해 안정성을 확보하고 출시 시간을 단축한다."
– RedHat

## 마이크로서비스 아키텍처
- 시스템 내부에서 어떤 서비스와 통신하는지 알 필요가 없는 외부의 API 클라이언트에게는 시스템의 복잡도를 숨긴다
- 게이트웨이는 클라이언트의 모든 요청을 다양한 API 종단점으로 동적으로 전달
- 동적이라는 말은 서비스 디스커버리의 목록에 기반한다는 뜻
- API게이트웨이는 시스템으로의 진입점이기 때문에 중요한 데이터를 추적하거나 요청 메트릭스를 수집하고 통계를 내기 좋은 장소가 될 수 있다
- 부가정보를 삽입하기 위해 요청 및 응답 헤더를 조작할 수도 있다

## 서비스 디스커버리의 필요성
- 컴퓨터 네트워크상의 디바이스가 제공하는 디바이스와 서비스를 자동으로 감지하는 서비스
- 모든 서비스는 시작 후 다른 서비스가 접근할 수 있는 하나의 중앙 장소에 자신을 등록


## 서비스 간 통신
- 시스템의 신뢰성을 보장하려면 각 서비스가 하나의 인스턴스로만 운영되게 하면 안된다
- 같은 서비스의 여러 인스턴스는 들어오는 요청에 대해 부하 분산을 적용해야 한다
- 부하 분산기는 대개 API 게이트웨이에 내장돼 있다
- 특별한 이유가 없다면 유입되는 트래픽을 50/50으로 모든 실행 중인 인스턴스에 분배하는 라운드 로빈 규칙을 적용한다

## 장애와 서킷 브레이커
- 대부분 장애의 발생 원인은 네트워크 또는 데이터베이스의 문제와 같이 관리의 범위를 벗어난다
- 하나의 요청이 많은 후속 호출에서 처리되는 마이크로서비스 기반의 시스템에서는 심각할 수 있다
- 가장 좋은 방법은 응답을 기다릴 때 네트워크 타임아웃을 활용하는 것이다
- 장시간 응답을 기다려서 스레드를 점유하는 대신 에러 응답을 보내는 것이 낫다
- 네트워크 타임아웃 문제에 대한 흥미로운 해결책은 서킷 브레이커 패턴일 수 있다
- 서킷 브레이커는 성공 및 실패 요청의 횟수를 센다
- 에러 비율이 가정된 임계치를 넘으면 차단이 발생하고 이후 즉시 실패된다
---
# Chap.2
## Configuration File 사용자 정의
- .properties와 .yml 위치
    - 애플리케이션의 현재 디렉토리의 /config 하위 디렉토리
    - 애플리케이션의 현재 니렉토리
    - 클래스 경로/config 패키지
    - 클래스 경로 root

## Spring Boot Actuator
- 애플리케이션의 모니터링과 메트릭 수집이 중요하다
- Boot 2 버전 부터 CounterService 및 GaugeService는 MeterRegistry로 이동되었다
- 문서화와 메트릭, 상태 점검에 많은 부분이 마이크로서비스를 개발하고 유지보수하는 데 매우 중요하다
- 하지만, 스프링 부트는 이러한 것을 즉시 제공하므로 개발자가 거기에 너무 많은 시간을 할애하지 않아도 된다
---
 # Chap.3
## 12-팩터 앱
- 확장이 가능하고 쉽게 클라우드 플랫폼에 배포할수 있으며 지속 배포 프로세스에 따라 배포되는 SaaS 개발 방법론
[참고](https://medium.com/dtevangelist/12-factors-%EB%9E%80-b39c7ef1ed30)

## 넷플릭스(Netflix) OSS
- 모놀리식 애플리케이션 기반의 전통적인 개발 모델에서 클라우드-네이티브 마이크로서비스 기반 개발 방식으로 전환한 선구자

## 유레카를 사용한 서비스 디스커버리
- 이 패키지는 클라이언트와 서버로 구분
- 클라이언트는 항상 애플리케이션의 일부로 원격의 디스커버리 서버에 연결하는 일을 담당
- 서비스 이름과 네트워크 위치를 담은 등록 메시지를 보낸다
- 서버는 독립적은 스프링 부트 애플리케이션으로 설정되고 실행되는데, 각 서버의 상태를 다른 서버에 복제해 가용성이 높다

## 주울을 사용한 라우팅
- JVM 기반의 라우터이며 서버 측 부하 분산과 일부 필터링을 수행
- 전체 시스템의 진입점을 제공하는 API 게이트웨이로서 중요한 역할을 한다
- 각 서비스의 네트워크 위치 정보를 알아야 하므로 유레카 서버와 통신하기 위해 디스커버리 클라이언트를 클래스 경로로 포함한다

## 리본을 사용한 부하 분산
- 클라이언트 측 부하 분산기
- TCP, UDP, HTTP 프로토콜 지원
- 동기 방식의 REST 호출뿐 아니라 비동기 또는 리액티브 모델도 지원
- 라운드 로빈, 가용성 필터링, 응답 시간에 가중치를 두어 부하 분산을 하는 등의 규칙을 즉시 제공하고 사용자 정의 규칙을 쉽게 확장할 수 있다
- 이름 기반 부하 분산을 하는 네임드 클라이언트 개념에 기반

## 자바 HTTP 클라이언트 작성하기
- 페인(Feign) 넷플릭스 OSS 패키지 중 약간 인기가 떨어진다
- 선언적인 REST 클라이언트로, 웹 서비스 클라이언트를 쉽게 작성하도록 도와준다
- 애노테이션을 선언하기만 하면 애플리케이션이 실행될 때 실제 구현이 실행된다

## 히스트릭스를 사용해 대기 시간 및 장애 내성 다루기
- 서킷 브레이커 패턴을 구현한 히스트릭스 패키지
- 리본과 페인 클라이언트를 통합할 수 있다


## 디스커버리와 분산 컨피규레이션
- 서비스 디스커버리와 분산 컨피규레이션 관리는 마이크로서비스 아키텍처에서 중요한 부분이다
- 아파치 주키퍼
    - 컨피규레이션과 이름을 유지하는 중앙 서비스로의 분산 동기호, 그룹 서비스를 가능하게 한다
- 쿠버네티스
    - 구글에서 설계된 시스템으로서 배포, 확장, 애플리케이션 컨테이너의 관리를 자동화는 시스템
- 슬루스를 사용한 분산 추적
    - 스프링 클라우드의 필수 기능 중 하나의 분산추적이다.
    - 대부분의 경우는 HTTP 헤더에 기반한 메커니즘으로 추적을 구현

....

# Chap. 4 서비스 디스커버리
- 넷플릭스 OSS 디스커버리 서버는 유레카(Eureka)로 알려져 있다
- 유레카와의 통합을 위한 스프링 클라우드 라이브러리는 클라이언트와 서버의 두 부분으로 구성돼 있다
- Server
    - 전용 스프링 부트 애플리케이션으로 실행한다
    - 등록된 서비스의 목록을 수집하기 위한 API
    - 새로운 서비스를 네트워크 위치 주소와 함께 등록하기 위한 API로 구성
    - 각 서버의 상태를 다른 서버로 복제해 설정하고 배포함으로써 가용성을 높일 수 있다
    - 서비스의 각 인스턴스로부터 생존신호(heartbeat) 메시지를 받는다
    - 설정된 기간 동안 하트비트 메시지를 받지 못하면 레지스트리에서 서비스가 삭제 된다
- Client
    - 마이크로서비스 애플리케이션에 의존성을 포함해 사용한다
    - 시작 후 등록과 종료 전 등록 해제를 담당하고 유레카 서버로부터 주기적으로 최신 서비스 목록을 받아온다
    - 종료 시 등록 해제
        - actuator 사용
        - /shutdown API 메서드를 POST로 호출한다
        - 실 세계에서 항상 올바른 결과를 얻는 것은 아니다
        - 디스커버리 클라이언트의 종료 절차가 시작되지 못해 서비스가 여전히 유레카 대시보드에 UP 상태로 나올 수 있다
    - 서버의 기본 설정을 변경해야 한다
        - 왜 기본 설정에서 문제가 발생하는가?
            - 자신의 서비스 등록 상태를 제 시간에 갱신하지 않는 서비스가 일정 수를 넘으면 등록 만료를 멈춘다
            - 이것은 네트워크 장애가 발생했을 때 등록된 모든 서비스가 해제되는 것을 방지한다
            - Self-preservation mode(자기 보호 모드)라고 부른다 (eureka.server.enable-self-preservation: false - 비활성화)
            
## 프로그램 방식으로 디스커버리 클라이언트 사용하기
- 클라이언트가 시작된 후 유레카 서버로부터 등록된 서비스 목록을 가져온다
    - com.netflix.discovery.EurekaClient : 유레카 서버가 노출하는 모든 API를 구현
    - org.springframework.cloud.client.discovery.Discoveryclient : 모든 디스커버리 클라이언트용으로 사용하는 간단한 범용 API

## IP 주소 우선하기
- 기본적으로 모든 인스턴스는 호스트명으로 등록된다
- 네트워크에 사용할 수 있는 DNS가 있다고 가정하면 이런 방식은 매우 편리하다
- 하지만, 마이크로서비스 환경을 구성하는 여러 서버를 위한 DNS가 없는 것이 일반적이다
- eureka.instance.preferIpAddress 속성을 true로 설정하여 IP 주소로 리디렉션하게 만든다
- 이 방법 또한 문제가 있으며 그 문제는 머신에 하나 이상의 네트워크 인터페이스가 있을 경우 발생
    ```yml
    spring:
        cloud:
            inetutils:
                # eth1로 시작하는 인터페이스 무시
                ignoredInterface:
                    - eth1*
                # 선호하는 네트워크 주소 정의
                preferredNetworks:
                    - 192.168
    ```

## 응답 캐시
- 유레카 서버는 기본적으로 응답을 캐싱한다

## 클라이언트와 서버 간의 보안 통신 사용하기 
- 허가되지 않은 접근을 방지하기 위해 디스커버리 서버에 기본 인증을 사용해 최소한 보안을 적용해야한다
- (security를 사용하는 방법이 되지 않음. 추후 수정)

## 복제와 고가용성
- 운영 모드에서는 디스커버리 서버의 장애나 네트워크 문제에 대비해 적어도 두 개의 디서커버리 서버를 구성해야 한다
- 유레카는 리더쉽 선출이나 클러스터에 자동 참여와 같은 표준 클러스터링 메커니즘을 제공하지는 않는다
- 동료 간 복제 모델에 기반한다
- 모든 서버가 현재 서버 노드에 구성된 모든 동료에게 데이터를 복제하고 하트비트를 보낸다는 것을 뜻한다
- 모든 노드가 서버에 저장하는 모든 부하를 견뎌야 한다

## 존(Zones)
- 동료 간 복제 모델 기반 클러스터는 대부분의 경우에 좋은 방법이지만 그것만으로는 충분하지 않다
- 존 메커니즘은 클라이언트 측에서만 실현된다는 점이다. 다시 말해 서비스 디스커버리 인스턴스는 어떤 존에도 할당되지 않는다